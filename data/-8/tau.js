import {Vector2} from "three";


const tau = new Vector2(0,Math.sqrt(2));

//these *dont* come directly from tau, as thats the wrong representation of the rectangle
//need to change coordinates in SL2Z: apply Tinv to move one to the left
//then apply S = -1/z
//this maps tau to a point along the circle (x-1/2)^2+y^2=1
//multiply by 2Pi to get (A/2,L/2)

const curveArea = 4*Math.PI/3;
const curveLength = 4*Math.PI/3*Math.sqrt(2);

//finding this curve is possible with basic trig!
//length is 2pi R for R the radius of cross section of sphere at height of curve
//this implies R = 2sqrt(2)/3.
//drawing a triangle shows the angle a from the horizontal at the equator is arccos(this).

let coordCurve = function(t){

    const a = Math.acos(2*Math.sqrt(2)/3);

    return {
        phi: Math.PI/2 - a,
        //this makes skinnier torus in projection. + a is OK too
        theta: t
    };
}


//takes in points in the standard FD gen by 1 and tau = sqrt(2)i
//changes to the lattice used by the hopf parameterization
//generated by 2pi and (a/2,l/2)
//this is NOT JUST A RESCALING:
let fromTauCoords = function(data) {
    //data is of form [x,y];
    let x = data[0];
    let y = data[1];

    //rotate by theta = arctan(sqrt2):
    let sin = Math.sqrt(2/3);
    let cos = Math.sqrt(1/3);
    let u = cos*x - sin*y;
    let v = sin*x + cos*y;

    //rescale
    u = u/Math.sqrt(3);
    v = v/Math.sqrt(3);

    //now scale by 2PI in all directions
    return new Vector2(u,v).multiplyScalar(2*Math.PI);
}

let latticeData = {
    tau:tau,
    length:curveLength,
    area:curveArea,
    fromTauCoords: fromTauCoords,
}


export {latticeData, coordCurve};
